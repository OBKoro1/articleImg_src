---
title: 算法_数组重复次数最多的元素&合并排序数组
date: 2018-09-23 14:34:19
tags:
- 算法
categories: 算法
---

## 找出数组重复次数最多的元素

### 难度：入门

### 描述：

给定一个字符串数组, 每一个元素代表一个 IP 地址，找到出现频率最高的 IP。

注：给定数据只有一个频率最高的 IP

### 样例：

```js
lines = ['192.168.1.1', '192.118.2.1', '192.168.1.1'];
return '192.168.1.1';
```

### 题目分析：

说了一堆，其实就是找出数组重复次数最多的元素

思路：

用对象来处理，将元素赋值到属性上，判断之前有没有这个属性。

**这个方法数组去重的缺点**：

虽然对象属性同样可以用来做数组去重，但是会将 number,NaN,undefined,null，变为字符串形式，因为对象的属性名就是一个字符串

### 代码：

```js
/**
 * @param ipLines: ip  address
 * @return: return highestFrequency ip address
 */
const highestFrequency = function(ipLines) {
  var [obj, max, name] = [{}, 1, ''];
  ipLines.forEach(value => {
    if (obj[value]) {
      // 已经有值了 就把值+1
      obj[value]++;
      if (obj[value] > max) { // 判断重复次数有没有超过当前最高的
        max = obj[value]; // 重复次数
        name = value; // 当前元素
      }
    } else {
      // 没有值 就初始化一个值
      obj[value] = 1;
    }
  });
  return name;
};
```
---

## 合并排序数组

### 难度：简单

### 描述：

合并**两个排序的整数数组 A 和 B 变成一个新的排序数组**。

### 样例：

给出`A=[1,2,3,4]`，`B=[2,4,5,6]`，返回 `[1,2,2,3,4,4,5,6]`

### 题目分析：

注意 A 和 B 本来就是排序好的数组，最简单的就是用`sort`排序了。

### `sort`排序

1. 把两个数组合并成一个数组
2. 用 sort 升序进行排序。

```js
const mergeSortedArray = function(A, B) {
  let newArr = A.concat(B); // 合并数组
  return newArr.sort((a, b) => {
    return a - b; // sort排序
  });
};
```

### 先对比完一个数组：

1. **初始两个变量分别对应一个数组**，进入循环

2. **i 和 j 不会同时递增**，只在对应数组元素打败另一数组元素时才会递增，只要打败一个即可，因为两个数组一开始就是排序好的

3. **i 和 j 必须有一个超过对应数组长度**(这样至少有一个数组的元素被逐一比较过)

4. 如果一个数组那边超过长度，会退出循环，但是可能由一方的长度还有剩余（比如一个元素打败另一数组的所有元素），所以我们需要**将长度有剩余的数组剩下的元素全都 push 到新数组中**(因为一开始就排序好的，后面出场的只会更强)

```js
const mergeSortedArray = function(A, B) {
  var i, j;
  var arr = [];
  for (i = 0, j = 0; i < A.length && j < B.length; ) {
    // i或者j必须有一个超过对应数组长度 才退出循环 所以至少有一个数组的元素被逐一比较
    if (A[i] < B[j]) {
      // 下面两种写法是一样的
      arr.push(A[i]);
      i++;
    } else {
      arr.push(B[j++]); // 这里会先把j赋值给B[j]， 然后再j++
    }
  }

  // 上面至少有一个数组已经比较了每个元素 如果还有一方长度有剩余 直接push进来就可以(AB一开始就是排序好的数组)
  while (i < A.length) {
    arr.push(A[i++]);
  }
  while (j < B.length) {
    arr.push(B[j++]);
  }
  return arr;
};
```